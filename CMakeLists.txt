cmake_minimum_required(VERSION 3.9)
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/cmake")

project(foobar
	LANGUAGES C CXX
	VERSION 1.2.3
)
string(TOUPPER "${PROJECT_NAME}" PROJECT_NAME_UPPER)
add_definitions(-D${PROJECT_NAME_UPPER}_VERSION_MAJOR=${PROJECT_VERSION_MAJOR})
add_definitions(-D${PROJECT_NAME_UPPER}_VERSION_MINOR=${PROJECT_VERSION_MINOR})
add_definitions(-D${PROJECT_NAME_UPPER}_VERSION_PATCH=${PROJECT_VERSION_PATCH})
add_definitions(-D${PROJECT_NAME_UPPER}_VERSION=${PROJECT_VERSION})
message( STATUS "${PROJECT_NAME_UPPER}_VERSION: ${PROJECT_VERSION}" )

set(CMAKE_C_STANDARD 11)
include(FeatureSummary)
include(CheckCCompilerFlag)
include(CheckLibraryExists)
include(CheckFunctionExists)
include(CheckIPOSupported)

if(NOT CMAKE_C_COMPILER_ID MATCHES "^(GNU|clang)$")
	message( "" )
	message( WARNING "You are using an untested toolchain" )
	message( "  The GNU toolchain is preferred on Linux" )
	message( "  The clang toolchain is preffered on FreeBSD" )
	message( "  You are in uncharted territory!" )
	message( "  Make sure you set CC and CXX" )
	message( "" )
	message( "  CC=gcc CXX=g++ ./configure --enable-<options>" )
	message( "    AND" )
	message( "  make CC=gcc CXX=g++" )
	message( "" )
	message( "" )
endif()

function(enable_c_flag flag)
	string(FIND "${CMAKE_C_FLAGS}" "${flag}" flag_already_set)
	if(flag_already_set EQUAL -1)
		check_c_compiler_flag("${flag}" flag_supported)
		if(flag_supported)
			set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${flag}" PARENT_SCOPE)
		endif()
	endif()
endfunction()

enable_c_flag("-std=gnu11")
enable_c_flag("-Wall")
enable_c_flag("-Wextra")
enable_c_flag("-Werror")

# Due to a bug in clang
enable_c_flag("-Wno-missing-braces")

# For gprof traces
#enable_c_flag("-pg")

# NOTE: Cannot enable this due to third-party using non-ISO features
#enable_c_flag("-pedantic")

find_package(bash-completion QUIET)
message( STATUS "BASH_COMPLETION_FOUND: '${BASH_COMPLETION_FOUND}'" )
message( STATUS "BASH_COMPLETION_COMPLETIONSDIR: '${BASH_COMPLETION_COMPLETIONSDIR}'" )

# Find pthreads
set(THREADS_PREFER_PTHREAD_FLAG ON)
find_package(Threads REQUIRED)

check_ipo_supported(RESULT IPO_SUPPORTED)
check_ipo_supported(RESULT result OUTPUT output)
if(IPO_SUPPORTED)
	set(HAS_IPO TRUE)
else()
	set(HAS_IPO FALSE)
endif()

if(CMAKE_SYSTEM MATCHES "Linux")
	set(FREEBSD 0)
	set(LINUX 1)
elseif(CMAKE_SYSTEM MATCHES "FreeBSD")
	set(FREEBSD 1)
	set(LINUX 0)
else()
	set(FREEBSD 0)
	set(LINUX 0)
endif()

message( STATUS "CMAKE_INTERPROCEDURAL_OPTIMIZATION: '${CMAKE_INTERPROCEDURAL_OPTIMIZATION}'" )
message( STATUS "IPO_SUPPORTED: '${IPO_SUPPORTED}'" )
message( STATUS "HAS_IPO: '${HAS_IPO}'" )

message( STATUS "CMAKE_C_FLAGS: '${CMAKE_C_FLAGS}'" )
message( STATUS "CMAKE_SYSTEM: '${CMAKE_SYSTEM}'" )
message( STATUS "CMAKE_SYSTEM_NAME: '${CMAKE_SYSTEM_NAME}'" )
message( STATUS "CMAKE_HOST_SYSTEM_NAME: '${CMAKE_HOST_SYSTEM_NAME}'" )
message( STATUS "CMAKE_C_COMPILER_AR: '${CMAKE_C_COMPILER_AR}'" )
message( STATUS "CMAKE_AR: '${CMAKE_AR}'" )

message( STATUS "UNIX(${UNIX}), FREEBSD(${FREEBSD}), LINUX(${LINUX}), WIN32(${WIN32})" )

if(WIN32)
	add_definitions(-D__USE_MINGW_ANSI_STDIO=1)
endif()

#
# Check for struct timespec ts and clock_gettime
#
check_library_exists(c clock_gettime "" LIBC_HAS_CLOCK_GETTIME)
check_library_exists(rt clock_gettime "time.h" LIBRT_HAS_CLOCK_GETTIME)

# On Windows we assume it is available via the TDM-GCC compiler suite
if(WIN32)
	message( WARNING "Skipping check for clock_gettime..." )
else ()
	if((NOT LIBC_HAS_BLOCK_GETTIME) AND (NOT LIBRT_HAS_CLOCK_GETTIME))
		message( FATAL_ERROR "Cannot find clock_gettime" )
	endif()
endif()

string(TOUPPER "${PROJECT_NAME}" PROJECT_NAME_UPPER)
set(PROJECT_DEBUG_NAME "${PROJECT_NAME_UPPER}_DEBUG_ENABLED")

set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -D${PROJECT_DEBUG_NAME}")

set(MGMT_TRACE_ENABLED FALSE CACHE BOOL "Enable tracing")
if(MGMT_TRACE_ENABLED)
	add_definitions(-DMGMT_TRACE_ENABLED)
endif()

#
# NOTE: CMake prefers that filenames are hard-coded in CMakeLists.txt and not
# globbed as it cannot detect, in the build-files generated by CMake, when a
# new file is added. However, it seems that value of that feature is less than
# the convenience file-globbing.
#
file(GLOB PUBLIC_FILES  ${PROJECT_SOURCE_DIR}/include/lib*.h)
file(GLOB INTERNAL_FILES  ${PROJECT_SOURCE_DIR}/include/*_*.h)
file(GLOB SOURCE_FILES  ${PROJECT_SOURCE_DIR}/src/*.c)

include_directories("${PROJECT_SOURCE_DIR}/include")

# Default 'clang' on FreeBSD does not look here, so we tell it to probably
# another symptom of 'base-system-compiler-we-do-not-care'
link_directories("/usr/local/lib")

#
# LIBS are the libraries which are "submoduled" by xNVMe and linked statically,
# and for the bundled version of the library embedded in the archive
#
list(APPEND LIBS "")

#
# AUX_LIB_PATHS non-system paths to search for libraries, search for 'LIBS here
#
list(APPEND AUX_LIB_PATHS "")

#
# LIBS_STATIC to be populated with absolute paths to 'LIBS' for bundling
#
list(APPEND LIBS_STATIC "")

#
# LIBS_SYSTEM are libraries which are expected to be available on the system on
# which xNVMe is built and at runtime when using the shared version of xNVMe
#
list(APPEND LIBS_SYSTEM Threads::Threads)

set(LIB_SHARED "${PROJECT_NAME}-shared")
set(LIB_SHARED_FN "${CMAKE_SHARED_LIBRARY_PREFIX}${PROJECT_NAME}${CMAKE_SHARED_LIBRARY_SUFFIX}")

set(LIB_STATIC "${PROJECT_NAME}-static")
set(LIB_STATIC_FN "${CMAKE_STATIC_LIBRARY_PREFIX}${PROJECT_NAME}${CMAKE_STATIC_LIBRARY_SUFFIX}")

# Static library
add_library(${LIB_STATIC} STATIC ${PUBLIC_FILES} ${INTERNAL_FILES} ${SOURCE_FILES})
set_target_properties(${LIB_STATIC} PROPERTIES
	INTERPROCEDURAL_OPTIMIZATION HAS_IPO
	OUTPUT_NAME ${PROJECT_NAME}
)
target_compile_options(${LIB_STATIC} PUBLIC -fPIC)
target_link_libraries(${LIB_STATIC} ${LIBS})
target_link_libraries(${LIB_STATIC} ${LIBS_SYSTEM})
install(TARGETS ${LIB_STATIC} DESTINATION lib COMPONENT dev)

# Shared library
add_library(${LIB_SHARED} SHARED ${PUBLIC_FILES} ${INTERNAL_FILES} ${SOURCE_FILES})
set_target_properties(${LIB_SHARED} PROPERTIES
	INTERPROCEDURAL_OPTIMIZATION HAS_IPO
	OUTPUT_NAME ${PROJECT_NAME}
)
target_compile_options(${LIB_SHARED} PUBLIC -fPIC)
target_link_libraries(${LIB_SHARED} ${LIBS})
target_link_libraries(${LIB_SHARED} ${LIBS_SYSTEM})
install(TARGETS ${LIB_SHARED} DESTINATION lib COMPONENT dev)
install(FILES ${PUBLIC_FILES} DESTINATION include COMPONENT dev)

add_subdirectory(examples)
add_subdirectory(tests)
add_subdirectory(tools)

#
# Packages
#
if(WIN32)
	set(CPACK_GENERATOR "NSIS" "ZIP")
else()
	set(CPACK_GENERATOR "TGZ" "DEB")
endif()
#set(CPACK_ARCHIVE_COMPONENT_INSTALL ON)
set(CPACK_PACKAGE_VERSION "${PROJECT_VERSION}")
set(CPACK_PACKAGE_VERSION_MAJOR "${PROJECT_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${PROJECT_VERSION_MINOR}")
set(CPACK_PACKAGE_VERSION_PATCH "${PROJECT_VERSION_PATCH}")
set(CPACK_PACKAGE_FILE_NAME "${CMAKE_PROJECT_NAME}-${PROJECT_VERSION}.bin")
set(CPACK_DEB_COMPONENT_INSTALL ON)
set(CPACK_DEBIAN_COMPONENT_INSTALL ON)
set(CPACK_DEBIAN_PACKAGE_MAINTAINER "Simon A. F. Lund")
set(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "amd64")
set(CPACK_COMPONENT_DEV_DESCRIPTION "headers and libraries")
if(TOOLS)
	set(CPACK_COMPONENT_TOOLS_DESCRIPTION
		"${PROJECT_NAME}-tools: command-line interface (CLI) tools")
endif()
if(EXAMPLES)
	set(CPACK_COMPONENT_EXAMPLES_DESCRIPTION
		"${PROJECT_NAME}-examples: examples provided as binaries")
endif()
if(TESTS)
	set(CPACK_COMPONENT_TESTS_DESCRIPTION
		"${PROJECT_NAME}-tests: test programs")
endif()

include(CPack)
